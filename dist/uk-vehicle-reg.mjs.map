{"version":3,"file":"uk-vehicle-reg.mjs","sources":["../src/rules.ts","../src/validate.ts","../src/format.ts"],"sourcesContent":["// Character Sets\r\n// NO_IQZ:   [A-HJ-PR-Y]      (A-Z except I, Q, Z)\r\n// NO_IQ:    [A-HJ-PR-Z]      (A-Z except I, Q)\r\n// NO_IQZOU: [A-HJ-NPR-TV-Y]  (A-Z except I, Q, Z, O, U)\r\n\r\n// Dateless (1903-1963)\r\n// Format 1: 1-3 letters, space, 1-4 numbers\r\n// Format 2: 1-4 numbers, space, 1-3 letters\r\n// Excludes I, Q, Z\r\nexport const DATELESS_REGEX = /^(([A-HJ-PR-Y]{1,3}[0-9]{1,4})|([0-9]{1,4}[A-HJ-PR-Y]{1,3}))$/;\r\n\r\n// Suffix (1963-1983)\r\n// Format: 3 letters (No I,Q,Z), space, 1-3 numbers, space, 1 letter (Year Suffix: No I,Q,Z,O,U)\r\nexport const SUFFIX_REGEX = /^([A-HJ-PR-Y]{3}[0-9]{1,3}[A-HJ-NPR-TV-Y])$/;\r\n\r\n// Prefix (1983-2001)\r\n// Format: 1 letter (Year Prefix: No I,Q,Z,O,U), 1-3 numbers, space, 3 letters (No I,Q,Z)\r\nexport const PREFIX_REGEX = /^([A-HJ-NPR-TV-Y][0-9]{1,3}[A-HJ-PR-Y]{3})$/;\r\n\r\n// Current (2001-Present)\r\n// Format: 2 letters (Region: No I,Q,Z), 2 numbers (Year), space, 3 letters (Random: No I,Q)\r\nexport const CURRENT_REGEX = /^([A-HJ-PR-Y]{2}[0-9]{2}[A-HJ-PR-Z]{3})$/;\r\n","import { DATELESS_REGEX, SUFFIX_REGEX, PREFIX_REGEX, CURRENT_REGEX } from './rules';\r\n\r\nexport interface ValidationResult {\r\n    isValid: boolean;\r\n    format?: 'Dateless' | 'Suffix' | 'Prefix' | 'Current';\r\n    errors: string[];\r\n}\r\n\r\nexport function validate(plate: string): ValidationResult {\r\n    // Normalize: remove spaces, optional uppercase\r\n    const cleanPlate = plate.replace(/\\s+/g, '').toUpperCase();\r\n    const errors: string[] = [];\r\n\r\n    if (!cleanPlate) {\r\n        return { isValid: false, errors: ['Input is empty'] };\r\n    }\r\n\r\n    // Check Current Style first (most common)\r\n    if (CURRENT_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Current', errors: [] };\r\n    }\r\n\r\n    // Check Prefix Style\r\n    if (PREFIX_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Prefix', errors: [] };\r\n    }\r\n\r\n    // Check Suffix Style\r\n    if (SUFFIX_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Suffix', errors: [] };\r\n    }\r\n\r\n    // Check Dateless Style\r\n    if (DATELESS_REGEX.test(cleanPlate)) {\r\n        // Additional Dateless Check: Max 6 characters\r\n        if (cleanPlate.length > 6) {\r\n            // Technically this might be caught by regex, but good to be explicit if regex matched loosely\r\n            // However, our regex strictly enforces char counts, so this block might purely be defensive.\r\n            // Let's rely on the regex for now.\r\n        }\r\n        return { isValid: true, format: 'Dateless', errors: [] };\r\n    }\r\n\r\n    // If no match, try to give helpful feedback\r\n    if (cleanPlate.length > 7) {\r\n        errors.push('Registration is too long (max 7 characters allowed)');\r\n    }\r\n\r\n    if (/[IQ]/.test(cleanPlate)) {\r\n        errors.push('Contains illegal characters (I or Q are typically not allowed in mainland formats)');\r\n    }\r\n\r\n    return { isValid: false, errors: errors.length > 0 ? errors : ['Invalid format'] };\r\n}\r\n","import { validate } from './validate';\r\n\r\nexport function format(plate: string): string {\r\n    const validation = validate(plate);\r\n    if (!validation.isValid) {\r\n        return plate.toUpperCase(); // Return raw uppercase if invalid\r\n    }\r\n\r\n    const cleanPlate = plate.replace(/\\s+/g, '').toUpperCase();\r\n\r\n    switch (validation.format) {\r\n        case 'Current':\r\n            // BD51 SMR (2 chars, 2 nums, space, 3 chars)\r\n            return `${cleanPlate.slice(0, 4)} ${cleanPlate.slice(4)}`;\r\n\r\n        case 'Prefix':\r\n            // A123 BCD (1 letter, 1-3 nums, space, 3 letters)\r\n            // The last 3 are always letters. Everything before is the prefix group.\r\n            const prefixSplit = cleanPlate.length - 3;\r\n            return `${cleanPlate.slice(0, prefixSplit)} ${cleanPlate.slice(prefixSplit)}`;\r\n\r\n        case 'Suffix':\r\n            // ABC 123D (3 letters, space, 1-3 nums, 1 letter)\r\n            // The first 3 are always letters.\r\n            return `${cleanPlate.slice(0, 3)} ${cleanPlate.slice(3)}`;\r\n\r\n        case 'Dateless':\r\n            // Dateless is tricky because the split depends on where the numbers/letters switch behavior.\r\n            // A 1 -> split after char\r\n            // 1 A -> split after num\r\n\r\n            // Find the boundary between digits and letters\r\n            // Search for the first occurrence where type changes from Letter to Digit or Digit to Letter\r\n\r\n            // Strategy: \r\n            // If starts with Letter: find first Digit.\r\n            // If starts with Digit: find first Letter.\r\n\r\n            const isFirstCharLetter = /[A-Z]/.test(cleanPlate[0]);\r\n            let splitIndex = -1;\r\n\r\n            if (isFirstCharLetter) {\r\n                // A 1, ABC 123\r\n                // Scan for first digit\r\n                const match = cleanPlate.match(/\\d/);\r\n                if (match) {\r\n                    splitIndex = match.index!;\r\n                }\r\n            } else {\r\n                // 1 A, 123 ABC\r\n                // Scan for first letter\r\n                const match = cleanPlate.match(/[A-Z]/);\r\n                if (match) {\r\n                    splitIndex = match.index!;\r\n                }\r\n            }\r\n\r\n            if (splitIndex !== -1) {\r\n                return `${cleanPlate.slice(0, splitIndex)} ${cleanPlate.slice(splitIndex)}`;\r\n            }\r\n            return cleanPlate; // Should happen?\r\n\r\n        default:\r\n            return cleanPlate;\r\n    }\r\n}\r\n"],"names":["DATELESS_REGEX","SUFFIX_REGEX","PREFIX_REGEX","CURRENT_REGEX","validate","plate","cleanPlate","errors","format","validation","prefixSplit","isFirstCharLetter","splitIndex","match"],"mappings":"AASO,MAAMA,IAAiB,iEAIjBC,IAAe,+CAIfC,IAAe,+CAIfC,IAAgB;ACbtB,SAASC,EAASC,GAAiC;AAEtD,QAAMC,IAAaD,EAAM,QAAQ,QAAQ,EAAE,EAAE,YAAA,GACvCE,IAAmB,CAAA;AAEzB,SAAKD,IAKDH,EAAc,KAAKG,CAAU,IACtB,EAAE,SAAS,IAAM,QAAQ,WAAW,QAAQ,GAAC,IAIpDJ,EAAa,KAAKI,CAAU,IACrB,EAAE,SAAS,IAAM,QAAQ,UAAU,QAAQ,GAAC,IAInDL,EAAa,KAAKK,CAAU,IACrB,EAAE,SAAS,IAAM,QAAQ,UAAU,QAAQ,GAAC,IAInDN,EAAe,KAAKM,CAAU,KAE1BA,EAAW,SAAS,GAKjB,EAAE,SAAS,IAAM,QAAQ,YAAY,QAAQ,GAAC,MAIrDA,EAAW,SAAS,KACpBC,EAAO,KAAK,qDAAqD,GAGjE,OAAO,KAAKD,CAAU,KACtBC,EAAO,KAAK,oFAAoF,GAG7F,EAAE,SAAS,IAAO,QAAQA,EAAO,SAAS,IAAIA,IAAS,CAAC,gBAAgB,EAAA,KAtCpE,EAAE,SAAS,IAAO,QAAQ,CAAC,gBAAgB,EAAA;AAuC1D;ACnDO,SAASC,EAAOH,GAAuB;AAC1C,QAAMI,IAAaL,EAASC,CAAK;AACjC,MAAI,CAACI,EAAW;AACZ,WAAOJ,EAAM,YAAA;AAGjB,QAAMC,IAAaD,EAAM,QAAQ,QAAQ,EAAE,EAAE,YAAA;AAE7C,UAAQI,EAAW,QAAA;AAAA,IACf,KAAK;AAED,aAAO,GAAGH,EAAW,MAAM,GAAG,CAAC,CAAC,IAAIA,EAAW,MAAM,CAAC,CAAC;AAAA,IAE3D,KAAK;AAGD,YAAMI,IAAcJ,EAAW,SAAS;AACxC,aAAO,GAAGA,EAAW,MAAM,GAAGI,CAAW,CAAC,IAAIJ,EAAW,MAAMI,CAAW,CAAC;AAAA,IAE/E,KAAK;AAGD,aAAO,GAAGJ,EAAW,MAAM,GAAG,CAAC,CAAC,IAAIA,EAAW,MAAM,CAAC,CAAC;AAAA,IAE3D,KAAK;AAYD,YAAMK,IAAoB,QAAQ,KAAKL,EAAW,CAAC,CAAC;AACpD,UAAIM,IAAa;AAEjB,UAAID,GAAmB;AAGnB,cAAME,IAAQP,EAAW,MAAM,IAAI;AACnC,QAAIO,MACAD,IAAaC,EAAM;AAAA,MAE3B,OAAO;AAGH,cAAMA,IAAQP,EAAW,MAAM,OAAO;AACtC,QAAIO,MACAD,IAAaC,EAAM;AAAA,MAE3B;AAEA,aAAID,MAAe,KACR,GAAGN,EAAW,MAAM,GAAGM,CAAU,CAAC,IAAIN,EAAW,MAAMM,CAAU,CAAC,KAEtEN;AAAA;AAAA,IAEX;AACI,aAAOA;AAAA,EAAA;AAEnB;"}