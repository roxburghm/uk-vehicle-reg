{"version":3,"file":"uk-vehicle-reg.iife.js","sources":["../src/rules.ts","../src/validate.ts","../src/format.ts"],"sourcesContent":["// Character Sets\r\n// NO_IQZ:   [A-HJ-PR-Y]      (A-Z except I, Q, Z)\r\n// NO_IQ:    [A-HJ-PR-Z]      (A-Z except I, Q)\r\n// NO_IQZOU: [A-HJ-NPR-TV-Y]  (A-Z except I, Q, Z, O, U)\r\n\r\n// Dateless (1903-1963)\r\n// Format 1: 1-3 letters, space, 1-4 numbers\r\n// Format 2: 1-4 numbers, space, 1-3 letters\r\n// Excludes I, Q, Z\r\nexport const DATELESS_REGEX = /^(([A-HJ-PR-Y]{1,3}[0-9]{1,4})|([0-9]{1,4}[A-HJ-PR-Y]{1,3}))$/;\r\n\r\n// Suffix (1963-1983)\r\n// Format: 3 letters (No I,Q,Z), space, 1-3 numbers, space, 1 letter (Year Suffix: No I,Q,Z,O,U)\r\nexport const SUFFIX_REGEX = /^([A-HJ-PR-Y]{3}[0-9]{1,3}[A-HJ-NPR-TV-Y])$/;\r\n\r\n// Prefix (1983-2001)\r\n// Format: 1 letter (Year Prefix: No I,Q,Z,O,U), 1-3 numbers, space, 3 letters (No I,Q,Z)\r\nexport const PREFIX_REGEX = /^([A-HJ-NPR-TV-Y][0-9]{1,3}[A-HJ-PR-Y]{3})$/;\r\n\r\n// Current (2001-Present)\r\n// Format: 2 letters (Region: No I,Q,Z), 2 numbers (Year), space, 3 letters (Random: No I,Q)\r\nexport const CURRENT_REGEX = /^([A-HJ-PR-Y]{2}[0-9]{2}[A-HJ-PR-Z]{3})$/;\r\n","import { DATELESS_REGEX, SUFFIX_REGEX, PREFIX_REGEX, CURRENT_REGEX } from './rules';\r\n\r\nexport interface ValidationResult {\r\n    isValid: boolean;\r\n    format?: 'Dateless' | 'Suffix' | 'Prefix' | 'Current';\r\n    errors: string[];\r\n}\r\n\r\nexport function validate(plate: string): ValidationResult {\r\n    // Normalize: remove spaces, optional uppercase\r\n    const cleanPlate = plate.replace(/\\s+/g, '').toUpperCase();\r\n    const errors: string[] = [];\r\n\r\n    if (!cleanPlate) {\r\n        return { isValid: false, errors: ['Input is empty'] };\r\n    }\r\n\r\n    // Check Current Style first (most common)\r\n    if (CURRENT_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Current', errors: [] };\r\n    }\r\n\r\n    // Check Prefix Style\r\n    if (PREFIX_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Prefix', errors: [] };\r\n    }\r\n\r\n    // Check Suffix Style\r\n    if (SUFFIX_REGEX.test(cleanPlate)) {\r\n        return { isValid: true, format: 'Suffix', errors: [] };\r\n    }\r\n\r\n    // Check Dateless Style\r\n    if (DATELESS_REGEX.test(cleanPlate)) {\r\n        // Additional Dateless Check: Max 6 characters\r\n        if (cleanPlate.length > 6) {\r\n            // Technically this might be caught by regex, but good to be explicit if regex matched loosely\r\n            // However, our regex strictly enforces char counts, so this block might purely be defensive.\r\n            // Let's rely on the regex for now.\r\n        }\r\n        return { isValid: true, format: 'Dateless', errors: [] };\r\n    }\r\n\r\n    // If no match, try to give helpful feedback\r\n    if (cleanPlate.length > 7) {\r\n        errors.push('Registration is too long (max 7 characters allowed)');\r\n    }\r\n\r\n    if (/[IQ]/.test(cleanPlate)) {\r\n        errors.push('Contains illegal characters (I or Q are typically not allowed in mainland formats)');\r\n    }\r\n\r\n    return { isValid: false, errors: errors.length > 0 ? errors : ['Invalid format'] };\r\n}\r\n","import { validate } from './validate';\r\n\r\nexport function format(plate: string): string {\r\n    const validation = validate(plate);\r\n    if (!validation.isValid) {\r\n        return plate.toUpperCase(); // Return raw uppercase if invalid\r\n    }\r\n\r\n    const cleanPlate = plate.replace(/\\s+/g, '').toUpperCase();\r\n\r\n    switch (validation.format) {\r\n        case 'Current':\r\n            // BD51 SMR (2 chars, 2 nums, space, 3 chars)\r\n            return `${cleanPlate.slice(0, 4)} ${cleanPlate.slice(4)}`;\r\n\r\n        case 'Prefix':\r\n            // A123 BCD (1 letter, 1-3 nums, space, 3 letters)\r\n            // The last 3 are always letters. Everything before is the prefix group.\r\n            const prefixSplit = cleanPlate.length - 3;\r\n            return `${cleanPlate.slice(0, prefixSplit)} ${cleanPlate.slice(prefixSplit)}`;\r\n\r\n        case 'Suffix':\r\n            // ABC 123D (3 letters, space, 1-3 nums, 1 letter)\r\n            // The first 3 are always letters.\r\n            return `${cleanPlate.slice(0, 3)} ${cleanPlate.slice(3)}`;\r\n\r\n        case 'Dateless':\r\n            // Dateless is tricky because the split depends on where the numbers/letters switch behavior.\r\n            // A 1 -> split after char\r\n            // 1 A -> split after num\r\n\r\n            // Find the boundary between digits and letters\r\n            // Search for the first occurrence where type changes from Letter to Digit or Digit to Letter\r\n\r\n            // Strategy: \r\n            // If starts with Letter: find first Digit.\r\n            // If starts with Digit: find first Letter.\r\n\r\n            const isFirstCharLetter = /[A-Z]/.test(cleanPlate[0]);\r\n            let splitIndex = -1;\r\n\r\n            if (isFirstCharLetter) {\r\n                // A 1, ABC 123\r\n                // Scan for first digit\r\n                const match = cleanPlate.match(/\\d/);\r\n                if (match) {\r\n                    splitIndex = match.index!;\r\n                }\r\n            } else {\r\n                // 1 A, 123 ABC\r\n                // Scan for first letter\r\n                const match = cleanPlate.match(/[A-Z]/);\r\n                if (match) {\r\n                    splitIndex = match.index!;\r\n                }\r\n            }\r\n\r\n            if (splitIndex !== -1) {\r\n                return `${cleanPlate.slice(0, splitIndex)} ${cleanPlate.slice(splitIndex)}`;\r\n            }\r\n            return cleanPlate; // Should happen?\r\n\r\n        default:\r\n            return cleanPlate;\r\n    }\r\n}\r\n"],"names":["DATELESS_REGEX","SUFFIX_REGEX","PREFIX_REGEX","CURRENT_REGEX","validate","plate","cleanPlate","errors","format","validation","prefixSplit","isFirstCharLetter","splitIndex","match"],"mappings":"2CASO,MAAMA,EAAiB,gEAIjBC,EAAe,8CAIfC,EAAe,8CAIfC,EAAgB,2CCbtB,SAASC,EAASC,EAAiC,CAEtD,MAAMC,EAAaD,EAAM,QAAQ,OAAQ,EAAE,EAAE,YAAA,EACvCE,EAAmB,CAAA,EAEzB,OAAKD,EAKDH,EAAc,KAAKG,CAAU,EACtB,CAAE,QAAS,GAAM,OAAQ,UAAW,OAAQ,EAAC,EAIpDJ,EAAa,KAAKI,CAAU,EACrB,CAAE,QAAS,GAAM,OAAQ,SAAU,OAAQ,EAAC,EAInDL,EAAa,KAAKK,CAAU,EACrB,CAAE,QAAS,GAAM,OAAQ,SAAU,OAAQ,EAAC,EAInDN,EAAe,KAAKM,CAAU,GAE1BA,EAAW,OAAS,EAKjB,CAAE,QAAS,GAAM,OAAQ,WAAY,OAAQ,EAAC,IAIrDA,EAAW,OAAS,GACpBC,EAAO,KAAK,qDAAqD,EAGjE,OAAO,KAAKD,CAAU,GACtBC,EAAO,KAAK,oFAAoF,EAG7F,CAAE,QAAS,GAAO,OAAQA,EAAO,OAAS,EAAIA,EAAS,CAAC,gBAAgB,CAAA,GAtCpE,CAAE,QAAS,GAAO,OAAQ,CAAC,gBAAgB,CAAA,CAuC1D,CCnDO,SAASC,EAAOH,EAAuB,CAC1C,MAAMI,EAAaL,EAASC,CAAK,EACjC,GAAI,CAACI,EAAW,QACZ,OAAOJ,EAAM,YAAA,EAGjB,MAAMC,EAAaD,EAAM,QAAQ,OAAQ,EAAE,EAAE,YAAA,EAE7C,OAAQI,EAAW,OAAA,CACf,IAAK,UAED,MAAO,GAAGH,EAAW,MAAM,EAAG,CAAC,CAAC,IAAIA,EAAW,MAAM,CAAC,CAAC,GAE3D,IAAK,SAGD,MAAMI,EAAcJ,EAAW,OAAS,EACxC,MAAO,GAAGA,EAAW,MAAM,EAAGI,CAAW,CAAC,IAAIJ,EAAW,MAAMI,CAAW,CAAC,GAE/E,IAAK,SAGD,MAAO,GAAGJ,EAAW,MAAM,EAAG,CAAC,CAAC,IAAIA,EAAW,MAAM,CAAC,CAAC,GAE3D,IAAK,WAYD,MAAMK,EAAoB,QAAQ,KAAKL,EAAW,CAAC,CAAC,EACpD,IAAIM,EAAa,GAEjB,GAAID,EAAmB,CAGnB,MAAME,EAAQP,EAAW,MAAM,IAAI,EAC/BO,IACAD,EAAaC,EAAM,MAE3B,KAAO,CAGH,MAAMA,EAAQP,EAAW,MAAM,OAAO,EAClCO,IACAD,EAAaC,EAAM,MAE3B,CAEA,OAAID,IAAe,GACR,GAAGN,EAAW,MAAM,EAAGM,CAAU,CAAC,IAAIN,EAAW,MAAMM,CAAU,CAAC,GAEtEN,EAEX,QACI,OAAOA,CAAA,CAEnB"}